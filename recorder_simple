#!/usr/bin/env python3
"""
Simplified TikTok Livestream Recorder
Focus on core recording functionality without complex dependencies
"""

import os
import sys
import time
import json
import logging
import threading
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class TikTokRecorder:
    def __init__(self):
        self.recording_processes = {}
        self.status_file = 'status.json'
        self.load_status()
        
    def load_status(self):
        """Load status from file"""
        try:
            if os.path.exists(self.status_file):
                with open(self.status_file, 'r') as f:
                    self.status = json.load(f)
            else:
                self.status = {}
        except Exception as e:
            logger.error(f"Error loading status: {e}")
            self.status = {}
    
    def save_status(self):
        """Save status to file"""
        try:
            with open(self.status_file, 'w') as f:
                json.dump(self.status, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving status: {e}")
    
    def update_status(self, username, **kwargs):
        """Update user status"""
        if username not in self.status:
            self.status[username] = {}
        self.status[username].update(kwargs)
        self.status[username]['last_updated'] = datetime.now().isoformat()
        self.save_status()
    
    def check_if_live(self, username):
        """Check if user is live using yt-dlp"""
        try:
            url = f"https://www.tiktok.com/@{username}/live"
            
            # Use yt-dlp to check
            cmd = ['yt-dlp', '--dump-json', '--no-download', url]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                data = json.loads(result.stdout)
                is_live = data.get('is_live', False)
                
                if is_live:
                    logger.info(f"✅ {username} is LIVE!")
                    self.update_status(username, is_live=True, last_seen_live=datetime.now().isoformat())
                    return True
                else:
                    logger.debug(f"❌ {username} is not live")
                    self.update_status(username, is_live=False)
                    return False
            else:
                logger.debug(f"Could not check {username}: {result.stderr[:100]}")
                return False
                
        except subprocess.TimeoutExpired:
            logger.warning(f"Timeout checking {username}")
            return False
        except json.JSONDecodeError:
            logger.debug(f"Could not parse response for {username}")
            return False
        except Exception as e:
            logger.error(f"Error checking {username}: {e}")
            return False
    
    def record_stream(self, username):
        """Record a livestream"""
        try:
            # Check if already recording
            if username in self.recording_processes:
                logger.warning(f"Already recording {username}")
                return
            
            # Create output directory
            output_dir = os.path.join('recordings', username)
            os.makedirs(output_dir, exist_ok=True)
            
            # Generate filename
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = os.path.join(output_dir, f'{username}_{timestamp}.mp4')
            
            url = f"https://www.tiktok.com/@{username}/live"
            
            logger.info(f"🔴 Starting recording for {username}")
            logger.info(f"📁 Output: {output_file}")
            
            # Update status
            self.update_status(
                username,
                is_recording=True,
                recording_start=datetime.now().isoformat(),
                current_file=output_file
            )
            
            # Start yt-dlp process
            cmd = [
                'yt-dlp',
                '-o', output_file,
                '--no-part',
                '--no-continue',
                url
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            self.recording_processes[username] = process
            
            # Wait for process to complete
            stdout, stderr = process.communicate()
            
            # Check results
            if process.returncode == 0:
                if os.path.exists(output_file):
                    file_size = os.path.getsize(output_file)
                    if file_size > 1024 * 1024:  # > 1MB
                        logger.info(f"✅ Recording completed for {username}: {output_file} ({file_size / 1024 / 1024:.2f} MB)")
                        self.update_status(
                            username,
                            last_recording=output_file,
                            last_recording_size=file_size,
                            recording_end=datetime.now().isoformat()
                        )
                    else:
                        logger.warning(f"Recording too small for {username}: {file_size} bytes")
                        os.remove(output_file)
                else:
                    logger.error(f"Recording file not created for {username}")
            else:
                logger.error(f"Recording failed for {username}: {stderr[:200]}")
            
        except Exception as e:
            logger.error(f"Error recording {username}: {e}")
        finally:
            # Clean up
            if username in self.recording_processes:
                del self.recording_processes[username]
            self.update_status(username, is_recording=False)
    
    def monitor_user(self, username):
        """Monitor a single user"""
        logger.info(f"Monitoring {username}...")
        
        while True:
            try:
                # Check if live
                if self.check_if_live(username):
                    # Start recording if not already
                    if username not in self.recording_processes:
                        # Record in a separate thread
                        thread = threading.Thread(
                            target=self.record_stream,
                            args=(username,),
                            daemon=True
                        )
                        thread.start()
                        
                        # Wait for recording to finish
                        thread.join()
                        
                        # Wait before checking again (cooldown after recording)
                        logger.info(f"Waiting 5 minutes before checking {username} again...")
                        time.sleep(300)  # 5 minutes
                else:
                    # Not live, check again in 1 minute
                    time.sleep(60)
                    
            except KeyboardInterrupt:
                logger.info(f"Stopping monitor for {username}")
                break
            except Exception as e:
                logger.error(f"Error monitoring {username}: {e}")
                time.sleep(60)
    
    def monitor_all_users(self, usernames):
        """Monitor all users in parallel"""
        logger.info(f"Starting monitoring for {len(usernames)} users")
        
        with ThreadPoolExecutor(max_workers=len(usernames)) as executor:
            futures = []
            for username in usernames:
                future = executor.submit(self.monitor_user, username)
                futures.append(future)
            
            # Wait for all to complete (they won't unless interrupted)
            try:
                for future in as_completed(futures):
                    future.result()
            except KeyboardInterrupt:
                logger.info("Stopping all monitors...")
                executor.shutdown(wait=False)

def load_usernames():
    """Load usernames from file"""
    try:
        with open('usernames.txt', 'r') as f:
            usernames = [
                line.strip().replace('@', '') 
                for line in f 
                if line.strip() and not line.startswith('#')
            ]
        return usernames
    except FileNotFoundError:
        logger.error("usernames.txt not found!")
        return []

def check_requirements():
    """Check if yt-dlp is installed"""
    try:
        result = subprocess.run(['yt-dlp', '--version'], capture_output=True)
        if result.returncode == 0:
            logger.info(f"yt-dlp version: {result.stdout.decode().strip()}")
            return True
    except FileNotFoundError:
        pass
    
    logger.error("yt-dlp is not installed!")
    logger.error("Install it with: pip install yt-dlp")
    return False

def main():
    """Main function"""
    print("=" * 60)
    print("🎥 TikTok Livestream Recorder")
    print("=" * 60)
    
    # Check requirements
    if not check_requirements():
        sys.exit(1)
    
    # Create directories
    os.makedirs('recordings', exist_ok=True)
    os.makedirs('logs', exist_ok=True)
    
    # Load usernames
    usernames = load_usernames()
    if not usernames:
        logger.error("No usernames found in usernames.txt")
        logger.error("Add TikTok usernames (one per line) to usernames.txt")
        sys.exit(1)
    
    logger.info(f"Loaded {len(usernames)} usernames: {', '.join(usernames)}")
    
    # Create recorder
    recorder = TikTokRecorder()
    
    # Start monitoring
    try:
        recorder.monitor_all_users(usernames)
    except KeyboardInterrupt:
        logger.info("\n👋 Stopped by user")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")

if __name__ == '__main__':
    main()